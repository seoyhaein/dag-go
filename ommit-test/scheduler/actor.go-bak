package scheduler

import (
	"context"
	"errors"
	"fmt"
	"log"
	"sync"
	"sync/atomic"
	"time"
)

// --- Actor commands ---

type CommandKind uint8

const (
	CmdRun CommandKind = iota
	CmdCancel
	CmdRunContainer
)

type Command struct {
	Kind    CommandKind
	RunReq  RunReq
	SpawnID string
	Sink    EventSink
	// slot=actor 정책에서는 release가 필요 없음(액터 생애 주기에서만 점유/반납).
	RunID   string
	NodeID  string
}

// ===== Router & Driver (스텁) =====

type Driver interface {
	RunContainer(ctx context.Context, c Command) error
}

type noopDriver struct{}

func (d *noopDriver) RunContainer(ctx context.Context, c Command) error {
	// 실제 실행 대신 짧은 지연으로 처리 흉내
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-time.After(10 * time.Millisecond):
		return nil
	}
}

type Router struct{ drv Driver }

func (r *Router) Handle(ctx context.Context, c Command) error {
	switch c.Kind {
	case CmdRunContainer:
		return r.drv.RunContainer(ctx, c)
	default:
		return errors.New("unknown command kind")
	}
}

// ===== Actor =====

type Actor struct {
	spawnID   string
	mbox      chan Command
	closing   atomic.Bool
	curMu     sync.Mutex
	curCancel context.CancelFunc

	router     *Router
	idleTTL    time.Duration
	onFinalize func()
}

func NewActor(spawnID string) *Actor {
	return &Actor{
		spawnID: spawnID,
		mbox:    make(chan Command, 64), // simple buffer
	}
}

func NewActor1(spawnID string, router *Router, idleTTL time.Duration, onFinalize func()) *Actor {
	return &Actor{
		spawnID:    spawnID,
		mbox:    make(chan Command, 1024),
		router:     router,
		idleTTL:    idleTTL,
		onFinalize: onFinalize,
	}
}

func (a *Actor) enqueue(c Command) bool {
	if a.closing.Load() {
		return false
	}
	select {
	case a.mbox <- c:
		return true
	default:
		return false
	}
}

func (a *Actor) loop() {
	for c := range a.mbox {
		switch c.Kind {
		case CmdRun:
			// Each Run handled sequentially (actor model)
			a.handleRun(c)
		case CmdCancel:
			// 최소 취소: 현재 실행 컨텍스트 취소
			a.curMu.Lock()
			if a.curCancel != nil {
				a.curCancel()
			}
			a.curMu.Unlock()
		}
	}
}

func (a *Actor) handleRun(c Command) {
	ctx, cancel := context.WithCancel(context.Background())
	// 현재 실행 취소 핸들 저장
	a.curMu.Lock()
	a.curCancel = cancel
	a.curMu.Unlock()
	defer func() {
		// 실행 종료 시 정리
		a.curMu.Lock()
		a.curCancel = nil
		a.curMu.Unlock()
		cancel()
	}()

	emit := func(level, state, msg string) {
		_ = c.Sink.Emit(RunRespEvent{
			When:    time.Now(),
			Level:   level,
			State:   state,
			Msg:     msg,
			RunID:   c.RunReq.RunID,
			NodeID:  c.RunReq.NodeID,
			SpawnID: c.SpawnID,
		})
	}

	emit("INFO", "Created", "actor accepted run")

	// Call driver
	drv := &FakeDriver{}
	if err := drv.Run(ctx, c.RunReq, func(e string) { emit("INFO", "Running", e) }); err != nil {
		emit("ERROR", "Failed", err.Error())
		return
	}
	emit("INFO", "Succeeded", "work done")
}

// ===== Event sink (simulating gRPC server stream) =====

type EventSink interface {
	Emit(ev RunRespEvent) error
}

type StdoutSink struct{}

func (StdoutSink) Emit(ev RunRespEvent) error {
	log.Printf("[%s] %s run=%s node=%s spawn=%s msg=%s",
		ev.Level, ev.State, ev.RunID, ev.NodeID, ev.SpawnID, ev.Msg)
	return nil
}

// ===== Fake driver (simulates Podman/K8s driver) =====


type FakeDriver struct{}


func (d *FakeDriver) Run(ctx context.Context, req RunReq, onProgress func(string)) error {
	onProgress("resolving image digest @sha256:…")
	time.Sleep(100 * time.Millisecond)
	onProgress("creating pod + container")
	time.Sleep(100 * time.Millisecond)
	onProgress("pulling inputs to /in (RO), preparing /work, /out")
	time.Sleep(100 * time.Millisecond)
	onProgress("executing userscript …")
	// Simulate work chunks
	for i := 1; i <= 3; i++ {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(200 * time.Millisecond):
			onProgress(fmt.Sprintf("step %d/3 ok", i))
		}
	}
	onProgress("uploading results to S3 (CAS)")
	return nil
}
